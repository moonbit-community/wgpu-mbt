#!/usr/bin/env python3

import re
from pathlib import Path


RE_EXPORT_START = re.compile(r"^WGPU_EXPORT\b")
RE_WGPU_START = re.compile(r"^\s*[A-Za-z_].*\bwgpu[A-Za-z0-9_]+\s*\(.*$")


def _collect_multiline_protos(lines: list[str], is_start) -> list[str]:
  protos: list[str] = []
  cur: list[str] | None = None
  for line in lines:
    if cur is None:
      if is_start(line):
        cur = [line.strip()]
        if ";" in line:
          protos.append(" ".join(cur))
          cur = None
    else:
      cur.append(line.strip())
      if ";" in line:
        protos.append(" ".join(cur))
        cur = None
  return protos


def _strip_attrs(proto: str) -> str:
  proto = proto.replace("WGPU_FUNCTION_ATTRIBUTE", "")
  proto = proto.replace("WGPU_EXPORT", "")
  return " ".join(proto.strip().split())


def _parse_func(proto: str) -> tuple[str, str, str]:
  # proto: "<ret> <name>(<args>) ;"
  proto = proto.strip()
  if not proto.endswith(";"):
    raise ValueError(f"proto does not end with ';': {proto}")
  proto = proto[:-1].strip()
  m = re.search(r"\b(wgpu[A-Za-z0-9_]+)\s*\(", proto)
  if not m:
    raise ValueError(f"cannot find function name in: {proto}")
  name = m.group(1)
  ret = proto[: m.start(1)].strip()
  args = proto[m.end(0) :].strip()
  if not args.endswith(")"):
    raise ValueError(f"cannot parse args in: {proto}")
  args = args[:-1].strip()
  return ret, name, args


_IDENT = re.compile(r"[A-Za-z_][A-Za-z0-9_]*")
_KEYWORDS = {
  "const",
  "volatile",
  "struct",
  "enum",
  "signed",
  "unsigned",
  "short",
  "long",
  "int",
  "float",
  "double",
  "void",
  "WGPU_NULLABLE",
}


def _split_args(args: str) -> list[str]:
  if not args or args == "void":
    return []
  out: list[str] = []
  depth = 0
  start = 0
  for i, ch in enumerate(args):
    if ch == "(":
      depth += 1
    elif ch == ")":
      depth -= 1
    elif ch == "," and depth == 0:
      out.append(args[start:i].strip())
      start = i + 1
  out.append(args[start:].strip())
  return [a for a in out if a]


def _arg_name(arg: str) -> str:
  # Heuristic: last identifier that isn't a keyword.
  ids = _IDENT.findall(arg)
  for ident in reversed(ids):
    if ident not in _KEYWORDS:
      return ident
  raise ValueError(f"cannot extract arg name from: {arg}")


def _emit_wrapper(ret: str, name: str, args: str) -> str:
  arg_list = _split_args(args)
  arg_names = [_arg_name(a) for a in arg_list]
  call_args = ", ".join(arg_names)
  typedef = f"typedef {ret} (*mbt_pfn_{name})({args if args else 'void'});"
  static = f"static mbt_pfn_{name} mbt_real_{name} = NULL;"
  sig = f"{ret} {name}({args if args else 'void'})"
  if ret == "void":
    body = (
      f"  if (!mbt_real_{name}) {{\n"
      f"    mbt_real_{name} = (mbt_pfn_{name})mbt_wgpu_sym(\"{name}\");\n"
      f"  }}\n"
      f"  mbt_real_{name}({call_args});\n"
    )
  else:
    body = (
      f"  if (!mbt_real_{name}) {{\n"
      f"    mbt_real_{name} = (mbt_pfn_{name})mbt_wgpu_sym(\"{name}\");\n"
      f"  }}\n"
      f"  return mbt_real_{name}({call_args});\n"
    )
  return "\n".join([typedef, static, sig + " {", body + "}", ""])


def main() -> None:
  repo = Path(__file__).resolve().parents[1]
  # Keep this generator dependency-free: we parse the checked-in headers under
  # src/c/ rather than reaching into an optional `vendor/` checkout.
  webgpu_h = repo / "src/c/webgpu.h"
  wgpu_h = repo / "src/c/wgpu_native_shim.h"
  out_c = repo / "src/c/wgpu_dyn.c"

  webgpu_lines = webgpu_h.read_text().splitlines()
  webgpu_protos = _collect_multiline_protos(webgpu_lines, lambda l: RE_EXPORT_START.match(l) is not None)
  webgpu_protos = [_strip_attrs(p) for p in webgpu_protos]

  # wgpu-native extras are declared in wgpu.h (no WGPU_EXPORT).
  wgpu_lines = wgpu_h.read_text().splitlines()
  wgpu_protos = _collect_multiline_protos(wgpu_lines, lambda l: RE_WGPU_START.match(l) is not None)
  wgpu_protos = [" ".join(p.strip().split()) for p in wgpu_protos]

  seen: set[str] = set()
  funcs: list[tuple[str, str, str]] = []
  for proto in webgpu_protos + wgpu_protos:
    try:
      ret, name, args = _parse_func(proto)
    except Exception:
      continue
    if name in seen:
      continue
    seen.add(name)
    funcs.append((ret, name, args))

  header = f"""// Auto-generated by scripts/gen_wgpu_dyn.py. DO NOT EDIT.
//
// This file provides a dependency-friendly implementation of the WebGPU C API:
// we export `wgpu*` symbols from our Moon native-stub archive, and forward them
// to `libwgpu_native` loaded at runtime (dlopen+dlsym).
//
// Motivation: Moon currently resolves relative native include/link flags from the
// consumer workspace root and does not reliably propagate dependency link flags.
// By avoiding link-time references to wgpu-native, consumer builds work without
// extra configuration.
//
// Runtime override: set `MBT_WGPU_NATIVE_LIB` to an absolute path to the dynamic
// library, e.g. `/path/to/libwgpu_native.dylib`.

#include "wgpu_native_shim.h"

#if defined(_WIN32)
#include <windows.h>
#include <wchar.h>
#else
#include <dlfcn.h>
#include <pthread.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined(_WIN32)
static HMODULE g_mbt_wgpu_lib = NULL;
static INIT_ONCE g_mbt_wgpu_once = INIT_ONCE_STATIC_INIT;
#else
static void *g_mbt_wgpu_lib = NULL;
static pthread_once_t g_mbt_wgpu_once = PTHREAD_ONCE_INIT;
#endif

static const char *mbt_wgpu_lib_filename(void) {{
#if defined(__APPLE__)
  return "libwgpu_native.dylib";
#elif defined(_WIN32)
  return "wgpu_native.dll";
#else
  return "libwgpu_native.so";
#endif
}}

static const char *mbt_wgpu_default_lib_path(char *buf, size_t buflen) {{
#if defined(_WIN32)
  const char *home = getenv("USERPROFILE");
  if (!home || !home[0]) {{
    return NULL;
  }}
  (void)snprintf(buf, buflen, "%s\\\\.local\\\\lib\\\\%s", home, mbt_wgpu_lib_filename());
  return buf;
#else
  const char *home = getenv("HOME");
  if (!home || !home[0]) {{
    return NULL;
  }}
  (void)snprintf(buf, buflen, "%s/.local/lib/%s", home, mbt_wgpu_lib_filename());
  return buf;
#endif
}}

#if defined(_WIN32)
static void mbt_wgpu_print_win32_error(DWORD err) {{
  if (err == 0) {{
    return;
  }}
  LPSTR buf = NULL;
  DWORD flags =
      FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS;
  DWORD len =
      FormatMessageA(flags, NULL, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                     (LPSTR)&buf, 0, NULL);
  if (!len || !buf) {{
    return;
  }}
  // The buffer usually ends with a newline; print as-is to keep it readable.
  fprintf(stderr, "wgpu-mbt: win32: %s", buf);
  LocalFree(buf);
}}
#endif

static void mbt_wgpu_die(const char *what) {{
  fprintf(stderr, "wgpu-mbt: %s", what);
#if defined(_WIN32)
  DWORD err = GetLastError();
  fprintf(stderr, " (GetLastError=%lu)\\n", (unsigned long)err);
  mbt_wgpu_print_win32_error(err);
#else
  fprintf(stderr, "\\n");
  const char *err = dlerror();
  if (err && err[0]) {{
    fprintf(stderr, "wgpu-mbt: dlerror: %s\\n", err);
  }}
#endif
  abort();
}}

static void mbt_wgpu_init(void) {{
  const char *override = getenv("MBT_WGPU_NATIVE_LIB");
  const char *path = (override && override[0]) ? override : NULL;
  char fallback[1024];
  if (!path) {{
    path = mbt_wgpu_default_lib_path(fallback, sizeof(fallback));
  }}
  if (!path || !path[0]) {{
    const char *lib = mbt_wgpu_lib_filename();
    char msg[512];
    (void)snprintf(
        msg,
        sizeof(msg),
        "cannot locate %s (set MBT_WGPU_NATIVE_LIB or install to ~/.local/lib)",
        lib);
    mbt_wgpu_die(msg);
  }}

  // Platform-specific dynamic loader.
#if defined(_WIN32)
  // Prefer LoadLibraryW for UTF-8 paths, but fall back to LoadLibraryA.
  g_mbt_wgpu_lib = NULL;
  int wlen = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, path, -1, NULL, 0);
  if (wlen > 0) {{
    wchar_t *wpath = (wchar_t *)malloc((size_t)wlen * sizeof(wchar_t));
    if (wpath) {{
      int ok = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, path, -1, wpath, wlen);
      if (ok > 0) {{
        g_mbt_wgpu_lib = LoadLibraryW(wpath);
      }}
      free(wpath);
    }}
  }}
  if (!g_mbt_wgpu_lib) {{
    g_mbt_wgpu_lib = LoadLibraryA(path);
  }}
  if (!g_mbt_wgpu_lib) {{
    char msg[512];
    (void)snprintf(msg, sizeof(msg), "failed to LoadLibrary{{W,A}}: %s", path);
    mbt_wgpu_die(msg);
  }}
#else
  g_mbt_wgpu_lib = dlopen(path, RTLD_LAZY | RTLD_LOCAL);
  if (!g_mbt_wgpu_lib) {{
    char msg[512];
    (void)snprintf(msg, sizeof(msg), "failed to dlopen: %s", path);
    mbt_wgpu_die(msg);
  }}
#endif
}}

#if defined(_WIN32)
static BOOL CALLBACK mbt_wgpu_init_once(PINIT_ONCE once, PVOID param, PVOID *ctx) {{
  (void)once;
  (void)param;
  (void)ctx;
  mbt_wgpu_init();
  return TRUE;
}}
#endif

static void *mbt_wgpu_sym(const char *name) {{
#if defined(_WIN32)
  InitOnceExecuteOnce(&g_mbt_wgpu_once, mbt_wgpu_init_once, NULL, NULL);
#else
  pthread_once(&g_mbt_wgpu_once, mbt_wgpu_init);
#endif
  if (!g_mbt_wgpu_lib) {{
    mbt_wgpu_die("wgpu native library handle is NULL");
  }}
#if defined(_WIN32)
  SetLastError(0);
  FARPROC sym = GetProcAddress(g_mbt_wgpu_lib, name);
  if (!sym) {{
    mbt_wgpu_die("failed to GetProcAddress required wgpu symbol");
  }}
  return (void *)sym;
#else
  dlerror();  // clear
  void *sym = dlsym(g_mbt_wgpu_lib, name);
  if (!sym) {{
    mbt_wgpu_die("failed to dlsym required wgpu symbol");
  }}
  return sym;
#endif
}}

"""

  body = "".join(_emit_wrapper(ret, name, args) for (ret, name, args) in funcs)
  out_c.write_text(header + body)

  print(f"generated {out_c} ({len(funcs)} functions)")


if __name__ == "__main__":
  main()
