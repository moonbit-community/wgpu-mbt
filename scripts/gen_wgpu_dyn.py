#!/usr/bin/env python3

import re
from pathlib import Path


RE_EXPORT_START = re.compile(r"^WGPU_EXPORT\b")
RE_WGPU_START = re.compile(r"^\s*[A-Za-z_].*\bwgpu[A-Za-z0-9_]+\s*\(.*$")


def _collect_multiline_protos(lines: list[str], is_start) -> list[str]:
  protos: list[str] = []
  cur: list[str] | None = None
  for line in lines:
    if cur is None:
      if is_start(line):
        cur = [line.strip()]
        if ";" in line:
          protos.append(" ".join(cur))
          cur = None
    else:
      cur.append(line.strip())
      if ";" in line:
        protos.append(" ".join(cur))
        cur = None
  return protos


def _strip_attrs(proto: str) -> str:
  proto = proto.replace("WGPU_FUNCTION_ATTRIBUTE", "")
  proto = proto.replace("WGPU_EXPORT", "")
  return " ".join(proto.strip().split())


def _parse_func(proto: str) -> tuple[str, str, str]:
  # proto: "<ret> <name>(<args>) ;"
  proto = proto.strip()
  if not proto.endswith(";"):
    raise ValueError(f"proto does not end with ';': {proto}")
  proto = proto[:-1].strip()
  m = re.search(r"\b(wgpu[A-Za-z0-9_]+)\s*\(", proto)
  if not m:
    raise ValueError(f"cannot find function name in: {proto}")
  name = m.group(1)
  ret = proto[: m.start(1)].strip()
  args = proto[m.end(0) :].strip()
  if not args.endswith(")"):
    raise ValueError(f"cannot parse args in: {proto}")
  args = args[:-1].strip()
  return ret, name, args


_IDENT = re.compile(r"[A-Za-z_][A-Za-z0-9_]*")
_KEYWORDS = {
  "const",
  "volatile",
  "struct",
  "enum",
  "signed",
  "unsigned",
  "short",
  "long",
  "int",
  "float",
  "double",
  "void",
  "WGPU_NULLABLE",
}


def _split_args(args: str) -> list[str]:
  if not args or args == "void":
    return []
  out: list[str] = []
  depth = 0
  start = 0
  for i, ch in enumerate(args):
    if ch == "(":
      depth += 1
    elif ch == ")":
      depth -= 1
    elif ch == "," and depth == 0:
      out.append(args[start:i].strip())
      start = i + 1
  out.append(args[start:].strip())
  return [a for a in out if a]


def _arg_name(arg: str) -> str:
  # Heuristic: last identifier that isn't a keyword.
  ids = _IDENT.findall(arg)
  for ident in reversed(ids):
    if ident not in _KEYWORDS:
      return ident
  raise ValueError(f"cannot extract arg name from: {arg}")


def _emit_wrapper(ret: str, name: str, args: str) -> str:
  arg_list = _split_args(args)
  arg_names = [_arg_name(a) for a in arg_list]
  call_args = ", ".join(arg_names)
  typedef = f"typedef {ret} (*mbt_pfn_{name})({args if args else 'void'});"
  static = f"static mbt_pfn_{name} mbt_real_{name} = NULL;"
  sig = f"{ret} {name}({args if args else 'void'})"
  if ret == "void":
    body = (
      f"  if (!mbt_real_{name}) {{\n"
      f"    mbt_real_{name} = (mbt_pfn_{name})mbt_wgpu_sym(\"{name}\");\n"
      f"  }}\n"
      f"  mbt_real_{name}({call_args});\n"
    )
  else:
    body = (
      f"  if (!mbt_real_{name}) {{\n"
      f"    mbt_real_{name} = (mbt_pfn_{name})mbt_wgpu_sym(\"{name}\");\n"
      f"  }}\n"
      f"  return mbt_real_{name}({call_args});\n"
    )
  return "\n".join([typedef, static, sig + " {", body + "}", ""])


def main() -> None:
  repo = Path(__file__).resolve().parents[1]
  # Keep this generator dependency-free: we parse the checked-in headers under
  # src/c/ rather than reaching into an optional `vendor/` checkout.
  webgpu_h = repo / "src/c/webgpu.h"
  wgpu_h = repo / "src/c/wgpu_native_shim.h"
  out_c = repo / "src/c/wgpu_dyn.c"

  webgpu_lines = webgpu_h.read_text().splitlines()
  webgpu_protos = _collect_multiline_protos(webgpu_lines, lambda l: RE_EXPORT_START.match(l) is not None)
  webgpu_protos = [_strip_attrs(p) for p in webgpu_protos]

  # wgpu-native extras are declared in wgpu.h (no WGPU_EXPORT).
  wgpu_lines = wgpu_h.read_text().splitlines()
  wgpu_protos = _collect_multiline_protos(wgpu_lines, lambda l: RE_WGPU_START.match(l) is not None)
  wgpu_protos = [" ".join(p.strip().split()) for p in wgpu_protos]

  seen: set[str] = set()
  funcs: list[tuple[str, str, str]] = []
  for proto in webgpu_protos + wgpu_protos:
    try:
      ret, name, args = _parse_func(proto)
    except Exception:
      continue
    if name in seen:
      continue
    seen.add(name)
    funcs.append((ret, name, args))

  header = f"""// Auto-generated by scripts/gen_wgpu_dyn.py. DO NOT EDIT.
//
// This file provides a dependency-friendly implementation of the WebGPU C API:
// we export `wgpu*` symbols from our Moon native-stub archive, and forward them
// to `libwgpu_native` loaded at runtime (dlopen+dlsym).
//
// Motivation: Moon currently resolves relative native include/link flags from the
// consumer workspace root and does not reliably propagate dependency link flags.
// By avoiding link-time references to wgpu-native, consumer builds work without
// extra configuration.
//
// Runtime override: set `MBT_WGPU_NATIVE_LIB` to an absolute path to the dynamic
// library, e.g. `/path/to/libwgpu_native.dylib`.

#include "wgpu_native_shim.h"

#include <dlfcn.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static void *g_mbt_wgpu_lib = NULL;
static pthread_once_t g_mbt_wgpu_once = PTHREAD_ONCE_INIT;

static const char *mbt_wgpu_lib_filename(void) {{
#if defined(__APPLE__)
  return "libwgpu_native.dylib";
#elif defined(_WIN32)
  return "wgpu_native.dll";
#else
  return "libwgpu_native.so";
#endif
}}

static void mbt_wgpu_die(const char *what) {{
  const char *err = dlerror();
  fprintf(stderr, "wgpu-mbt: %s\\n", what);
  if (err && err[0]) {{
    fprintf(stderr, "wgpu-mbt: dlerror: %s\\n", err);
  }}
  abort();
}}

static void mbt_wgpu_init(void) {{
  const char *override = getenv("MBT_WGPU_NATIVE_LIB");
  if (!override || !override[0]) {{
    const char *lib = mbt_wgpu_lib_filename();
    char msg[256];
    (void)snprintf(
        msg,
        sizeof(msg),
        "MBT_WGPU_NATIVE_LIB is not set (set it to a path to %s)",
        lib);
    mbt_wgpu_die(msg);
  }}

  g_mbt_wgpu_lib = dlopen(override, RTLD_LAZY | RTLD_LOCAL);
  if (!g_mbt_wgpu_lib) {{
    mbt_wgpu_die("failed to dlopen MBT_WGPU_NATIVE_LIB");
  }}
}}

static void *mbt_wgpu_sym(const char *name) {{
  pthread_once(&g_mbt_wgpu_once, mbt_wgpu_init);
  if (!g_mbt_wgpu_lib) {{
    mbt_wgpu_die("wgpu native library handle is NULL");
  }}
  dlerror();  // clear
  void *sym = dlsym(g_mbt_wgpu_lib, name);
  if (!sym) {{
    mbt_wgpu_die("failed to dlsym required wgpu symbol");
  }}
  return sym;
}}

"""

  body = "".join(_emit_wrapper(ret, name, args) for (ret, name, args) in funcs)
  out_c.write_text(header + body)

  print(f"generated {out_c} ({len(funcs)} functions)")


if __name__ == "__main__":
  main()
